module AusfallSzenarien {
	
	
	
	import from Lib_Http all;

	import from UserIdService all;
	import from Lib_ServiceManagement all;
	import from Templates_Ausfallszeanrien all;

		

        
		testcase status_services() runs on RESTComponent {
				var charstring serviceStat_logingateway := getServiceStatus(LoginGW);
				var charstring serviceStat_authservice := getServiceStatus(Authservice);
				var charstring serviceStat_userservice := getServiceStatus(Userservice);
				const charstring antwort:= "Running";
		
				log("LoginGateway is " & serviceStat_logingateway);
				log("AuthService is " & serviceStat_authservice);
				log("UserService is " & serviceStat_userservice);
				

				if (serviceStat_logingateway == antwort and serviceStat_authservice== antwort and serviceStat_userservice== antwort) {
					setverdict(pass);
					stop;
				}
				
				setverdict(fail);	

				
			}
		   
	
		
						
		testcase test_RESTPost_LoginGateway_ausfall_userservice() runs on RESTComponent system LoginRestService {
					log("Der Userservice is " & getServiceStatus(Userservice));
					log(stopService(Userservice));
					log("Der Userservice is " & getServiceStatus(Userservice));
					map(mtc:p, system:s) param (config(AUTHORIZATION));
					p.send(loginRequest);
					timer t;
					t.start(5.0);
					var HTTPResponse valHttp;
					alt {
					[] p.receive(LoginResponse:{ body := ?, authorization := omit}) {
							setverdict(pass);
						}
					[] p
					   .receive(HTTPResponse:
								{
									statusLine := {statusCode := 500, reasonPhrase := *},
									headers := ?,
									body := *
								}) -> value valHttp{
								var charstring jwt := valHttp.headers[8].val;
								//	log("The jwt is:" & jwt);
							setverdict(pass);
							t.stop;
						}
					[] p.receive {
							setverdict(fail);
						}
					[] t.timeout {
							setverdict(fail);
						}
					}
					// write a Methode to start the service again
					log(startService(Userservice));
				}
		testcase test_RESTPost_LoginGateway_ausfall_authservice() runs on RESTComponent system LoginRestService {
							log("Der Authservice is " & getServiceStatus(Authservice));
							log(stopService(Authservice));
							log("Der Authservice is " & getServiceStatus(Authservice));
							map(mtc:p, system:s) param (config(AUTHORIZATION));
							p.send(loginRequest);
							timer t;
							t.start(5.0);
							var HTTPResponse valHttp;
							alt {
							[] p.receive(LoginResponse:{ body := ?, authorization := omit}) {
									setverdict(pass);
								}
							[] p
							   .receive(HTTPResponse:
										{
											statusLine := {statusCode := 500, reasonPhrase := *},
											headers := ?,
											body := *
										}) -> value valHttp{
										var charstring jwt := valHttp.headers[8].val;
										//	log("The jwt is:" & jwt);
									setverdict(pass);
									t.stop;
								}
							[] p.receive {
									setverdict(fail);
								}
							[] t.timeout {
									setverdict(fail);
								}
							}
							//write a Methode to start the service again
							log(startService(Authservice));
						}
						
	testcase test_RESTPost_LoginGateway_ausfall_loginGateway() runs on RESTComponent system LoginRestService {
								log("Das LoginGateway is " & getServiceStatus(LoginGW));
								log(stopService(LoginGW));
								log("Das LoginGateway is " & getServiceStatus(LoginGW));
								map(mtc:p, system:s) param (config(AUTHORIZATION));
								p.send(loginRequest);
								timer t;
								t.start(5.0);
								var HTTPResponse valHttp;
								alt {
								[] p.receive(LoginResponse:{ body := omit, authorization := ?}) {
										setverdict(pass);
									}
								[] p
								   .receive(HTTPResponse:
											{
												statusLine := {statusCode := 500, reasonPhrase := *},
												headers := ?,
												body := *
											}) -> value valHttp{
											var charstring jwt := valHttp.headers[8].val;
											//	log("The jwt is:" & jwt);
										setverdict(pass);
										t.stop;
									}
								[] p.receive {
										setverdict(fail);
									}
								[] t.timeout {
										setverdict(pass);
									}
								}
								// write a Methode to start the service again
								log(startService(LoginGW));
							}
	testcase test_RESTPost_LoginGateway_Alle_weg_wiederDa() runs on RESTComponent system LoginRestService {
											
											log("LoginGateway is " & getServiceStatus(LoginGW));
											log("AuthService is " & getServiceStatus(Authservice));
											log("UserService is " & getServiceStatus(Userservice));
											stopService(LoginGW);
											stopService(Authservice);
											stopService(Userservice);
											log("LoginGateway is " & getServiceStatus(LoginGW));
											log("AuthService is " & getServiceStatus(Authservice));
											log("UserService is " & getServiceStatus(Userservice));
											log(startService(LoginGW));
											log(startService(Authservice));
											log(startService(Userservice));
											log("LoginGateway is " & getServiceStatus(LoginGW));
											log("AuthService is " & getServiceStatus(Authservice));
											log("UserService is " & getServiceStatus(Userservice));
											timer t_Delay := 90.0; 
											t_Delay.start;
											t_Delay.timeout;
											map(mtc:p, system:s) param (config(AUTHORIZATION));
											p.send(loginRequest);
											timer t;
											t.start(5.0);
											var HTTPResponse valHttp;
											alt {
											[] p.receive(LoginResponse:{ body := omit, authorization := ?}) {
													setverdict(pass);
												}
											[] p
											   .receive(HTTPResponse:
														{
															statusLine := {statusCode := 200, reasonPhrase := *},
															headers := ?,
															body := *
														}) -> value valHttp{
														var charstring jwt := valHttp.headers[8].val;
														//	log("The jwt is:" & jwt);
													setverdict(pass);
													t.stop;
												}
											[] p.receive {
													setverdict(fail);
												}
											[] t.timeout {
													setverdict(fail);
												}
											}
										
										}
		testcase test_RESTPost_LoginGateway_wiederkommen_LoginGateway() runs on RESTComponent system LoginRestService {
										log("Das LoginGateway is " & getServiceStatus(LoginGW));
										log(stopService(LoginGW));
										log("Das LoginGateway is " & getServiceStatus(LoginGW));
										log(startService(LoginGW));
										log("Das LoginGateway is " & getServiceStatus(LoginGW));
										timer t_Delay := 80.0; 
										t_Delay.start;
										t_Delay.timeout;
										map(mtc:p, system:s) param (config(AUTHORIZATION));
										p.send(loginRequest);
										timer t;
										t.start(5.0);
										var HTTPResponse valHttp;
										alt {
										[] p.receive(LoginResponse:{ body := omit, authorization := ?}) {
												setverdict(pass);
											}
										[] p
										   .receive(HTTPResponse:
													{
														statusLine := {statusCode := 200, reasonPhrase := *},
														headers := ?,
														body := *
													}) -> value valHttp{
													var charstring jwt := valHttp.headers[8].val;
													//	log("The jwt is:" & jwt);
												setverdict(pass);
												t.stop;
											}
										[] p.receive {
												setverdict(fail);
											}
										[] t.timeout {
												setverdict(fail);
											}
										}
										
									}
		
		testcase test_RESTPost_LoginGateway_wiederkommen_userservice() runs on RESTComponent system LoginRestService {
								log("Der Userservice is " & getServiceStatus(Userservice));
								log(stopService(Userservice));
								log("Der Userservice is " & getServiceStatus(Userservice));
								log(startService(Userservice));
								log("Der Userservice is " & getServiceStatus(Userservice));
								timer t_Delay := 80.0; 
								t_Delay.start;
								t_Delay.timeout;
								map(mtc:p, system:s) param (config(AUTHORIZATION));
								p.send(loginRequest);
								timer t;
								t.start(5.0);
								var HTTPResponse valHttp;
								alt {
								[] p.receive(LoginResponse:{ body := omit, authorization := ?}) {
										setverdict(pass);
									}
								[] p
								   .receive(HTTPResponse:
											{
												statusLine := {statusCode := 200, reasonPhrase := *},
												headers := ?,
												body := *
											}) -> value valHttp{
											var charstring jwt := valHttp.headers[8].val;
											//	log("The jwt is:" & jwt);
										setverdict(pass);
										t.stop;
									}
								[] p.receive {
										setverdict(fail);
									}
								[] t.timeout {
										setverdict(fail);
									}
								}
								
							}
							
		testcase test_RESTPost_LoginGateway_wiederkommen_authservice() runs on RESTComponent system LoginRestService {
										log("Der Authservice is " & getServiceStatus(Authservice));
										log(stopService(Authservice));
										log("Der Authservice is " & getServiceStatus(Authservice));
										log(startService(Authservice));
										log("Der Authservice is " & getServiceStatus(Authservice));
										timer t_Delay := 80.0; 
										t_Delay.start;
										t_Delay.timeout;
								
										map(mtc:p, system:s) param (config(AUTHORIZATION));
										p.send(loginRequest);
										timer t;
										t.start(5.0);
										var HTTPResponse valHttp;
										alt {
										[] p.receive(LoginResponse:{ body := omit, authorization := ?}) {
												setverdict(pass);
											}
										[] p
										   .receive(HTTPResponse:
													{
														statusLine := {statusCode := 200, reasonPhrase := *},
														headers := ?,
														body := *
													}) -> value valHttp{
													var charstring jwt := valHttp.headers[8].val;
													//	log("The jwt is:" & jwt);
												setverdict(pass);
												t.stop;
											}
										[] p.receive {
												setverdict(fail);
											}
										[] t.timeout {
												setverdict(fail);
											}
										}
										//write a Methode to start the service again
									}
						testcase test_RESTPost_userservice_wiederkommen() runs on RESTComponent_userservice system LoginRestService_userservice {
							log("Der Userservice is " & getServiceStatus(Userservice));
							log(stopService(Userservice));
							log("Der Userservice is " & getServiceStatus(Userservice));
							log(startService(Userservice));
							log("Der Userservice is " & getServiceStatus(Userservice));
							timer t_Delay := 20.0; 
							t_Delay.start;
							t_Delay.timeout;
							map(mtc:p, system:s) param (config_user(AUTHORIZATION));
							p.send(loginRequest_userservice);
							timer t;
							t.start(5.0);
							var HTTPResponse valHttp;
							alt {
							[] p.receive(LoginResponse_user:{ body := ?, authorization := omit}) {
									setverdict(pass);
								}
							[] p
							   .receive(HTTPResponse:
										{
											statusLine := {statusCode := 200, reasonPhrase := *},
											headers := ?,
											body := ?
										
										}) -> value valHttp{
											var charstring id := valHttp.body.messageBodyTxt;
											log("The userId is:" & id);
									setverdict(pass);
									t.stop;
								}
							[] p.receive {
									setverdict(fail);
								}
							[] t.timeout {
									setverdict(fail);
								}
							}
						}
				testcase test_RESTPost_authservice_wiederkommen() runs on RESTComponent_authservice system LoginRestService_authservice {
							log("Der Authservice is " & getServiceStatus(Authservice));
							log(stopService(Authservice));
							log("Der Authservice is " & getServiceStatus(Authservice));
							log(startService(Authservice));
							log("Der Authservice is " & getServiceStatus(Authservice));
							timer t_Delay := 20.0; 
							t_Delay.start;
							t_Delay.timeout;
							map(mtc:p, system:s) param (config_auth(AUTHORIZATION));
							p.send(loginRequest_authservice);
							timer t;
							t.start(5.0);
							var HTTPResponse valHttp;
							alt {
							[] p.receive(LoginResponse_auth:{ body := ?, authorization := omit}) {
									setverdict(pass);
								}
							[] p
							   .receive(HTTPResponse:
										{
											statusLine := {statusCode := 200, reasonPhrase := *},
											headers := ?,
											body := ?
								
										}) -> value valHttp{
											var charstring answer := valHttp.body.messageBodyTxt;
											log("The answer is:" & answer);
									setverdict(pass);
									t.stop;
								}
							[] p.receive {
									setverdict(fail);
								}
							[] t.timeout {
									setverdict(fail);
								}
							}
						}
		        
				  
				   }
	

with {
	encode "RESTfull/json"
}
	





	