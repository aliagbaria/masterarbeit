module REST_POST_UserId {
	import from Lib_Http all;

	import from UserIdService all;



	group integration {
        
		   
		testcase test_RESTPost_LoginGateway() runs on RESTComponent system DBRestService {
			log("Check REST/put call towards DB");
			map(mtc:p, system:s) param (config(AUTHORIZATION));
			p.send(loginRequest);
			timer t;
			t.start(5.0);
			var HTTPResponse valHttp;
			alt {
			[] p.receive(LoginResponse:{ body := omit, authorization := ?}) {
					setverdict(pass);
				}
			[] p
			   .receive(HTTPResponse:
						{
							statusLine := {statusCode := 200, reasonPhrase := *},
							headers := ?,
							body := *
						}) -> value valHttp{
						var charstring jwt := valHttp.headers[8].val;
						//	log("The jwt is:" & jwt);
					setverdict(pass);
					t.stop;
				}
			[] p.receive {
					setverdict(fail);
				}
			[] t.timeout {
					setverdict(fail);
				}
			}
		}
			testcase test_RESTPost_userservice() runs on RESTComponent_userservice system DBRestService_userservice {
			log("Check REST/put call towards DB");
			map(mtc:p, system:s) param (config_user(AUTHORIZATION));
			p.send(loginRequest_userservice);
			timer t;
			t.start(5.0);
			var HTTPResponse valHttp;
			alt {
			[] p.receive(LoginResponse_user:{ body := ?, authorization := omit}) {
					setverdict(pass);
				}
			[] p
			   .receive(HTTPResponse:
						{
							statusLine := {statusCode := 200, reasonPhrase := *},
							headers := ?,
							body := ?
						
						}) -> value valHttp{
							var charstring id := valHttp.body.messageBodyTxt;
							log("The userId is:" & id);
					setverdict(pass);
					t.stop;
				}
			[] p.receive {
					setverdict(fail);
				}
			[] t.timeout {
					setverdict(fail);
				}
			}
		}
		testcase test_RESTPost_authservice() runs on RESTComponent_authservice system DBRestService_authservice {
					log("Check REST/put call towards DB");
					map(mtc:p, system:s) param (config_auth(AUTHORIZATION));
					p.send(loginRequest_authservice);
					timer t;
					t.start(5.0);
					var HTTPResponse valHttp;
					alt {
					[] p.receive(LoginResponse_auth:{ body := ?, authorization := omit}) {
							setverdict(pass);
						}
					[] p
					   .receive(HTTPResponse:
								{
									statusLine := {statusCode := 200, reasonPhrase := *},
									headers := ?,
									body := ?
						
								}) -> value valHttp{
									var charstring answer := valHttp.body.messageBodyTxt;
									log("The answer is:" & answer);
							setverdict(pass);
							t.stop;
						}
					[] p.receive {
							setverdict(fail);
						}
					[] t.timeout {
							setverdict(fail);
						}
					}
				}
        
		  
		   }
	
}
with {
	encode "RESTfull/json"
}
